1.main.js里放公共样式css或js
import '../static/css/reset.css'
import 'animate.css'
import './common/css/public.styl'
import './common/js/rem.js'



stylus的mixin混合

border-radius($px=10px)
    -webkit-border-radius:$px;
    -moz-border-radius:$px;
    -o-border-radius:$px;
    border-radius:$px;
2.
./这是相对路径的意思。
@/这是webpack设置的路径别名。
resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
    }
  },
就是说@这东西代表着到src这个文件夹的路径

3.vue项目的顶部导航是用fixed定位, router-view使用animated.css切换, 会出现导航fixed中的文字跟随router-view移动, 
解决, 在fixed中加入display:table;


手机端$(document).scrollTop()取值总为0的问题
$(window).on("pageshow",function(){
    var bdScrollTop=$(document).scrollTop();
	alert(bdScrollTop);			
  })
  注意：上面的写法是拿不到bfcache属性的；
  如果你要判断当前环境是否存在BFcache(BF缓存)，则要这么写：

window.addEventListener("pageshow",function(e){
	var bdScrollTop=$(document).scrollTop();
	alert(bdScrollTop);
	
	//判断当前页面是否来自bfcache；
	var e=e||event;
	if(!e.persisted){
		//如果当前环境不是来自bfcache；
		alert(e.persisted);
	}
},false)
//其他情况下取值为0也可以这么做

//其实解决问题的办法也很简单，就是把要写的代码加到pageshow方法里面来即可，无论怎么进入页面都可以取到scrollTop的值；ok！

手机端的scrollTop
设置document.body.scrolLTop才生效, document.documentElement.scrollTop没有生效

在调用json文件的vue里面这样写
在项目开发的时候，很多时候后台接口可能更不上前台的开发速度，需要我们自己写好json文件，这样就可以把静态页面和逻辑结合起来调试了，等到后台写好接口的时候我们只需要把请求地址替换一下就好。
在vue项目中，我们一般使用axios来请求接口数据，那么请求本地的json文件请求路径怎么写呢？
项目结构：
大家一定要注意，本地的json文件是在static文件里面放着的
1.如何引入axios，import、prototype
  本地JSON文件需放在static文件夹之下。（以及图片文件）。参见http://blog.csdn.net/Mr_YanYan/article/details/78783091
2.response是个Object对象，但是response.data才是本地JSON文件的对象
3.response.data已经是一个Object类型；原生JS写Ajax返回的response是string类型
4.JSON文件不得有注释，否则返回的是string
5.JSON文件如果有注释，JSON.parse报错含有非法字符/。JSON文件本来就是对象，再用
JSON.parse(),会报错含有非法字符o

Vue.js 提供了我们一个获取 DOM 对象的接口—— vm.$refs
<div class="equip_list" res="equip_list"></div>
this.$refs


五.安装cube-ui,  webpack-transform-modules-plugin ,webpack-post-compile-plugin
npm install cube-ui --save
npm install webpack-transform-modules-plugin webpack-post-compile-plugin --save-dev

后编译, 添加代码
1.package.json
"scripts": {},
"transformModules": {
    "cube-ui": {
      "transform": "cube-ui/src/modules/${member}",
      "kebabCase": true
    }
},
"dependencies": {}

2.webpack.base.conf.js 添加
const TransformModulesPlugin = require('webpack-transform-modules-plugin')
const PostCompilePlugin = require('webpack-post-compile-plugin')

module.exports = {
  ..//
  module: {},
  node: {},
  plugins: [
    new PostCompilePlugin(),
    new TransformModulesPlugin()
  ]
}

3.修改 build/utils.js 中的 exports.cssLoaders 函数
exports.cssLoaders = function (options) {
    ../

    const stylusOptions = {
        'resolve url': true
    }

    // https://vue-loader.vuejs.org/en/configurations/extract-css.html
    return {
    css: generateLoaders(),
    postcss: generateLoaders(),
    less: generateLoaders('less'),
    sass: generateLoaders('sass', { indentedSyntax: true }),
    scss: generateLoaders('sass'),
    stylus: generateLoaders('stylus', stylusOptions),
    styl: generateLoaders('stylus', stylusOptions)
    }
}

4.main.js 全局引入
import {
    Style,
    Button,
    CheckboxGroup,
    Radio,
    Input,
    Textarea,
    Select,
    Switch,
    Rate,
    Validator,
    Form,
    Loading,
    Tip,
    Popup,
    Toast,
    Picker,
    CascadePicker,
    DatePicker,
    SegmentPicker,
    TimePicker,
    Dialog,
    ActionSheet,
    Drawer,
    Scroll,
    Slide,
    IndexList,
    Swipe,
    Upload
} from 'cube-ui'

  Vue.use(Button)
  Vue.use(CheckboxGroup)
  Vue.use(Radio)
  Vue.use(Input)
  Vue.use(Textarea)
  Vue.use(Select)
  Vue.use(Switch)
  Vue.use(Rate)
  Vue.use(Validator)
  Vue.use(Form)
  Vue.use(Loading)
  Vue.use(Tip)
  Vue.use(Toast)
  Vue.use(Picker)
  Vue.use(CascadePicker)
  Vue.use(DatePicker)
  Vue.use(SegmentPicker)
  Vue.use(TimePicker)
  Vue.use(Dialog)
  Vue.use(ActionSheet)
  Vue.use(Drawer)
  Vue.use(Scroll)
  Vue.use(Slide)
  Vue.use(IndexList)
  Vue.use(Swipe)
  Vue.use(Upload)


vue 手指库
1.安装腾讯的web手势库AlloyFinger发布 
npm install alloyfinger --save
main.js全局引入
import AlloyFinger from 'alloyfinger'
import AlloyFingerPlugin from 'alloyfinger/vue/alloy_finger.vue'
Vue.use(AlloyFingerPlugin, {
    AlloyFinger
})


2.安装transform.js
npm install css3transform
引入
import Transform from "css3transform"
使用
Transform(this.$refs.pinchImg);


vue的事件传递本身this
@click="change($event)"

var vm=new  Vue({
        el:"#app",
        methods:{
            change(event){
                console.log(event.currentTarget)
            }
        }
    })


2018.5.14
打包
npm run build

外网路径在cpc根目录下 (http://taoalan.com/cpc/)
module.exports = {
  build: {
    // Paths
    assetsSubDirectory: 'static',
    assetsPublicPath: '/cpc/',          // 外网的根目录
}


页面图片路径写
static/images/index/Index-1.jpg

重新打包后基本传几个文件
index.html
js/的文件
css/的文件

static放不会变动的文件 assets放可能会变动的文件。

/src/assets/的图片都会被打包
/static/的文件不会被打包



三.什么是bfcache
bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，
还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件

1.pageshow事件
这个事件在页面显示时触发，无论页面是否来自bfcache。在重新加载的页面中，pageshow会在load事件触发后触发；而对于bfcache中的页面，pageshow会在页面状态完全恢复的那一刻触发。

2.pagehide事件
该事件会在浏览器卸载页面的时候触发，而且是在unload事件之前触发。

3.persisted属性
pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。
  对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。
  对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。

JS监听pageshow事件阻止页面进入bfcache
window.addEventListener('pageshow', function( e ){
    if (e.persisted) {
        window.location.reload()
    }
})


四, vue跟踪路由是进入哪个页面
APP.vue
watch: {
    '$route' (to, from) {
        console.group("路由页面")
            console.log(from);
            console.log(to);
            console.log("前一页面: " + from.path + " ,进入的页面是: " + to.path);
        console.groupEnd("路由页面")
    }
},


五, 导航中根目录中的route-link :to中要加入"/" 根目录, 这样在次级目录url就不会错


